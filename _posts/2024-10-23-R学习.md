---
layout: post
title:  " R学习"
tags: 实验方法与科研小技巧
date:   2024-10-23
categories: Front-end JavaScript
excerpt: 实验方法与科研小技巧
---

**目录：**

* content
{:toc}

#R语言初学者指南

# 文件保存与读取

## 将文件保存成excel

```R
library(writexl)
write_xlsx(保存对象, "文件命名.xlsx")
list.files()  #列出当前文件夹下的所有文件
```




#第一章 引言

```R

#字体用consolas，Editor theme使用Merbivore；
?boxplot  #求助方法
help("boxplot")  #求助方法
q()  #会询问是否保存工作空间
q(save = "no")  #不会询问是否保存工作空间

#将R代码保存到文本编辑器中，不要保存到工作空间；若计算机需要花费很长时间才能去完成的时候可以通过File——Save Workspace进行保存，通过

getwd()  #获取当前工作目录
rm(list=ls(all=TRUE)) 或者 rm(list=ls()) #移除所有变量

#更改R版本：tools--global Options--General--R version-change--choose a specific version of R语言初学者指南

# ctrl + shift + c 一次性注释很多行，一次性取消很多注释也是如此
# R包安装：install.packages("plotrix")；如果使用install.packages(plotrix)就无法安装成功
# 小键盘上的0可以将R中的光标从竖直变为横着；
```



# 第二章  R 中的数据输入

## 数据的 bind结合/sum运算（中括号查看）/dim维度/rep重复/

```R
Wingcrd<-c(59,55,53.5,55,52.5,57.5,53,55)  #c()函数生成了一个长度为8的向量
Wingcrd[1]  #查看第一个值
Wingcrd[1:5]  #查看前五个值
Wingcrd[-2]  #查看除第二个之外的值
sum(Wingcrd)  #求和
Tarsus<-c(22.3,19.7,20.8,20.3,20.8,21.5,20.6,21.5)
Head<-c(31.2,30.4,30.6,30.3,30.3,30.8,32.5,NA)
Wt<-c(9.5,13.8,14.8,15.2,15.5,15.6,15.6,15.7)
sum(Head)
sum(Head,na.rm = T) #na.rm 移除缺失值

#使用c,cbind,rbind结合变量
BirdData<-c(Wingcrd,Tarsus,Head,Wt);BirdData#c结合变量会生成一个变量
Z<-cbind(Wingcrd,Tarsus,Head,Wt);Z#cbind结合的变量会以列的形式输出
Z2<-rbind(Wingcrd,Tarsus,Head,Wt);Z2#rbind结合的变量会以行的形式输出

Id<-rep(c(1,2,3,4),each=8);Id   # 
Id <- rep(1:4,each=8);Id    # 每个单独重复
Id <- rep(1:4,times=8);Id   # 大家一起重复

a<-seq( from=1 , to = 4 , by=1 );a
rep(a,each=8)

VarName<-c("Wingcrd","Tarsus","Head","Wt")  #以字符形式结合
Id2<-rep(VarName,each=8);Id2
Z<-cbind(Wingcrd,Tarsus,Head,Wt);Z  #cbind结合的变量会以列的形式输出,c表示column

dim(Z)  #查看维度
dim(Z)[3]
```

## 矩阵形成&数据填充& col/row name命名，bind、矩阵结合要类型相同，data.frame结合数据，数据类型、长度可以不同。如果list，取元素双括号、可不同类型不同长度。read.table读取txt，factor


```R
#使用矩阵结合数据
Dmat<-matrix(nrow = 8, ncol = 4)  #生成一个8X4的矩阵
Dmat
Dmat[,1]<-c(59,55,53.5,55,52.5,57.5,53,55)  #对矩阵进行数据填充
Dmat[,2]<-c(22.3,19.7,20.8,20.3,20.8,21.5,20.6,21.5)
Dmat[,3]<-c(31.2,30.4,30.6,30.3,30.3,30.8,32.5,NA)
Dmat[,4]<-c(9.5,13.8,14.8,15.2,15.5,15.6,15.6,15.7)
Dmat  #此时矩阵行和列还没有名字
colnames(Dmat)<-c("Wingcrd","Tarsus","Head","Wt")  #使用colnames函数给Dmat的列加上名字; 注意一点，就是这个函数放在了 <-的左边！
rownames(Dmat)<-c("甲","乙","丙","丁","戊","己","庚","辛")  #使用rownames函数给Dmat的行加上名字
Dmat

#使用数据框（data.frame函数）结合数据
Dfrm<-data.frame(Wingcd=Wingcrd,Tarsus=Tarsus,Head=Head,Wt=Wt);Dfrm
#cbind和matrix只能结合相同类型的数据,而data.frame可以结合不同类型的数据

#使用list函数结合数据
#R中几乎所有的函数的输出结果都是保存在list中
x1 <- c(1,2,3)   #三个数字的向量
x2 <- c("a","b","c","d")   #三个字符的向量
x3 <- 3
x4 <- matrix(nrow = 2,ncol = 2)   #矩阵
x4[,1] <- c(1,2)  #给矩阵赋值
x4[,2] <- c(3,4)  #给矩阵赋值
x4
y <- list(x1=x1,x2=x2,x3=x3,x4=x4)  #用list将x1,x2,x3,x4这四个变量结合起来,若改为y <- list(x1,x2,x3,x4)，则下一步的y$x2无法正常运行. =左边是自定义的名字，=右边是实质性内容；
y$x2
y
y[[1]] #取list的元素使用[[]]来实现
y[[2]]
y[[2]][1]

AllData <- list(BirdData=BirdData,Id=Id2,Z=Z,VarName=VarName)  # =左边是自定义的名字，=右边是实质性内容；
AllData
AllData$BirdData
AllData[[1]]
tmp<-AllData[[3]]
class(tmp)
AllData[[3]][1,] #因为AllData第三个元素Z是matrix，所以AllData[[3]][1,] 表示取该matrix的第一行
AllData[[3]][,1] #表示取该matrix的第一列

# read.table读取的是txt文件

#可以使用绝对路径
Squid <- read.table(file = "D:/生信学习/猪年年尾R学习笔记/R语言初学者指南/乌贼数据.txt",header =T,dec=".")  #file =不写也可以；read.table读取的是txt文件！

#也可以通过.Rproj后缀文件来先进行定位，然后直接读取即可。
Squid <- read.table(file = "乌贼数据.txt",header =T,dec=".") 
#header =T 有表头；dec=".",小数点字符为.
Squid
head(Squid)  #head函数看前几行
# 当一个目录下面有很多文件需要读取，可以先利用setwd函数设置一下工作路径，然后再read.table
setwd("D:/生信学习/猪年年尾R学习笔记/R语言初学者指南/")  #若上面使用了.Rproj进行了定位，则这里不可以更改路径。
Squid<-read.table(file="乌贼数据.txt",header = T)
```
![image](https://github.com/user-attachments/assets/c5dd17cb-a358-42da-90e2-c8093868c019)





# 第三章  访问变量和处理数据子集

## 访问data.frame变量用$，或者attach（查看某列），unique还有布尔向量（查看某行），是==，或|，且& ，非!==，<= ，>=。 order排序，重编码分类变量factor。

```R
#read.table函数应该和names以及str函数始终结合起来；因为这样可以查看变量，并且查看每个变量的属性；保证下一步不会出现错误；
setwd("D:/生信学习/猪年年尾R学习笔记/R语言初学者指南")
Squid<-read.table(file = "https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/A-beginner's-guide-to-R/%E4%B9%8C%E8%B4%BC%E6%95%B0%E6%8D%AE.txt",header = T,dec = ".")
Squid
names(Squid) #查看正在处理的变量
str(Squid) #查看数据框中每个变量的属性
head(Squid) #查看前几行
class(Squid)

Squid2<-read.table(file = "乌贼数据.txt",header = T,dec = ",") #我们如果将小数点错误的标为“，” 则GSI会被认为成一个因子(它不再是数值型变量)，继续使用函数作图将会产生错误；
names(Squid2) #查看正在处理的变量
str(Squid2) #查看数据框中每个变量的属性。发现出了问题，GSI成为了因子。
class(Squid2)

# ******访问数据框中的变量 ---------------------------------------------------------------
# 方法一：$符号进行访问
Squid$GSI  #通过$符号访问数据框中的变量；
mean(Squid$GSI)  #计算均值

#方法二：先attach，然后输入GSI
attach(Squid)  #使用attach命令将Squid添加到R的搜索路径里面
GSI  #避免每次输入Squid$
boxplot(GSI)
detach(Squid)  #用detach命令将Squid从R的搜索路径里面移除
GSI  #发现找不到


# ******结合布尔运算符访问数据子集 ------------------------------------------------------------
unique(Squid$Sex)  #显示这个变量里面有多少个唯一值
#访问所有性别为1的数据
Sel <- Squid$Sex ==1  #生成一个布尔向量用来选择行，若sex为1则该变量的值是TRUE，否则为FALSE
Sel
SquidM <- Squid[Sel,]  #选择Sel为TRUE的行; 注意选的是“行”，所以Sel放 = 前面
#以上两个步骤也可以合成一个步骤：SquidM <- Squid[Squid$Sex ==1,]
SquidM

#访问数据Squid的Location为1,2,3的子集(即Location为1，2，3的行，所以后面要加逗号)
Squid123 <- Squid[Squid$Location ==1|Squid$Location ==2|Squid$Location ==3,] #|表示布尔运算符“或”
#以下三种也可以
# Squid123 <- Squid[Squid$Location !=4,] != 表示“不等于”
# Squid123 <- Squid[Squid$Location <=3,]
# Squid123 <- Squid[Squid$Location >=1 & Squid$Location <=3,]
Squid.1 <- Squid[Squid$Sex ==1 & Squid$Location ==1,] #需要满足Sex为1和Location为1两个条件，因为要提取符合条件的行，所以写在 = 前面
Squid.1
Squid.2 <- Squid[Squid$Sex ==1 & (Squid$Location ==1|Squid$Location ==2),] #需要满足Sex为1和Location为1或者2两个条件
Squid.2


# ******数据排序 --------------------------------------------------------------
Squid
Ord1 <- order(Squid$MONTH) #对月份进行排序
Ord1  
Squid[Ord1,]  #月份排序之后的Squid，为何要放在行上？？？因为要以排序后的月份对Squid每一行进行排列！
Squid$MONTH[Ord1] #月份排序之后的月份
Squid$Sample[Ord1]  #月份排序之后的Sample


# ******数据集组合 -------------------------------------------------------------
setwd("D:/生信学习/猪年年尾R学习笔记/R语言初学者指南")
Sq1 <- read.table(file = "乌贼数据1.txt",header = T) #读取文件1
Sq2 <- read.table(file = "乌贼数据2.txt",header = T) #读取文件2
Sq1
Sq2
SquidMerged <- merge(Sq1, Sq2, by="Sample",all=T)  #使用变量Sample作为相同的标识符合并两个数据集,all=T表示如果有缺失值将用NA来填充；如果all=F则表示如果有缺失值将忽略；
#所谓的缺失值是指整行的缺失(这一点非常重要，意思是Sq1缺失了几个整行或者Sq2缺失了几个整行！)
SquidMerged


# ******数据输出 --------------------------------------------------------------
SquidM <- Squid[Squid$Sex ==1,]  #提取Sex为1的数据
write.table(SquidM,file = "MaleSquid.txt",sep = "",quote = F,append = F, na = "NA") #将上一步提取出来的数据输出到MaleSquid.txt里面
getwd()  #当前路径就是该文件所在路径
#通过write.table输出之后就可以发现多了一个文件，名为MaleSquid.txt。


# ******重新编码分类变量 ----------------------------------------------------------
Squid
Squid$fLocation <- factor(Squid$Location, levels = c(1,2,3,4), labels = c("甲","乙","丙","丁")) #创建一个新的列，名字叫fLocation，它的内容就是将Location的1,2,3,4换为了甲乙丙丁
Squid$fLocation
Squid
Squid$fSex <- factor(Squid$Sex,levels = c(1,2),labels = c("M","F")) #创建一个新的列，名字叫fLocation，它的内容就是将Sex的1,2换为了M和F
Squid$fSex
Squid
boxplot(GSI ~ fSex, data =Squid) #把Squid的GSI和fSex分别拿出来，对应着进行boxplot画图；
```


# 第四章 简单的函数 

## apply函数t、s、l，S产生向量，l是list；summary提供信息。


```R
setwd("c:/RBook/")
Veg <- read.table(file="Vegetation2.txt", header =TRUE);head(Veg)
names(Veg)
str(Veg)
class(Veg)

m <- mean(Veg$R)  #Veg$R表示将Veg中的R这一子集单独提取出来；mean(Veg$R)表示对Veg中R这一子集进行求取平均值；
m
m1 <- mean(Veg$R[Veg$Transect == 1])  #从外往里看，首先这是求平均值，求Veg中R这一子集的平均值，但不是求取所有R的平均值，有一个条件，就是被求取平均值的R要满足Transect为1, []之中为R要满足的条件。注意条件要用[ ]括起来；
m2 <- mean(Veg$R[Veg$Transect == 2])
m3 <- mean(Veg$R[Veg$Transect == 3])
m4 <- mean(Veg$R[Veg$Transect == 4])
m5 <- mean(Veg$R[Veg$Transect == 5])
m6 <- mean(Veg$R[Veg$Transect == 6])
m7 <- mean(Veg$R[Veg$Transect == 7])
m8 <- mean(Veg$R[Veg$Transect == 8])
c(m, m1, m2, m3, m4, m4, m5, m6, m7, m8)


# ******tapply函数 ----------------------------------------------------------
#tapply函数可以根据INDEX的不同水平对X进行FUN的运算
Veg$Transect
Me <- tapply(Veg$R, Veg$Transect, mean)  #等同于 Me <- tapply(X = Veg$R, INDEX = Veg$Transect ,FUN = mean)
Me
Sd <- tapply(Veg$R, Veg$Transect, sd)   #等同于 Sd <- tapply(X = Veg$R, INDEX = Veg$Transect, sd)
Sd
Le <- tapply(Veg$R, Veg$Transect, length) #等同于 Le <- tapply(X = Veg$R, INDEX = Veg$Transect, length)
Le
cbind(Me, Sd, Le)

# ******sapply函数 ----------------------------------------------------------
Me <- mean(Veg$R) #求整个序列的均值
Mi <- min(Veg$R)  #求整个序列的最小值
Ma <- max(Veg$R)  #求整个序列的最大值
Sd <- sd(Veg$R)  #求整个序列的标准差
Le <- length(Veg$R)  #求整个序列的长度
c(Me,Mi,Ma,Sd,Le)
names(Veg)  #通过names函数我们可以发现有很多变量
length(Veg)  #通过length函数我们发现有24个变量，如果我们想对每一个变量都求平均值，就需要使用mean()函数24次
#sapply函数可以避免以上囧状

sapply(Veg[, 5:10], FUN = mean)  #对Veg的5到10列求取mean值
sapply(Veg[, 5:10], function(x) {mean(x)})  #与上面等价

lapply(Veg[, 5:10], FUN = mean)  #lapply和sapply函数一样功能，只不过输出结果形式不一样；sapply函数的输出是一个向量，lapply函数的输出是一个列表；
lapply(Veg[, 5:10], function(x) {mean(x)})

# 总结：tapply函数计算的是一个变量观察值子集的均值(或其他函数)；
# lapply和sapply函数计算的是一个或多个变量全部观察值的均值（或其他函数）；
# lapply和sapply中包含数据的变量应该是数据框(lapply也可以是list);sapply产生向量，lapply产生列表；


# ****** summary函数 ------------------------------------------------------------
# summary函数可以提供变量基本信息
Z <-cbind(Veg$R, Veg$ROCK, Veg$LITTER, Veg$ML)  #使用cbind将几个变量结合起来
Z
head(Z)
colnames(Z) <- c("R","ROCK","LITTER","ML")  #如果没有这一步输出的结果每一列会没有名字，这一步的作用是给每一列添加名字！
head(Z)
summary(Z) #提供变量信息
names(Veg)

summary(Veg[,c("R","ROCK","LITTER","ML")])  #可以实现同样的功能
summary(Veg[,c(5,6,7,8)])  #可以实现同样的功能

setwd("D:/生信学习/猪年年尾R学习笔记/R语言初学者指南/RBook")
Deer <- read.table(file="Deer.txt")
names(Deer)
str(Deer)

table(Deer$Farm)
table(Deer$Sex, Deer$Year)
```


# 第五章 基础绘图工具简介 ----------------------------------------------------------



```R
setwd("c:/RBook/")
Veg <- read.table(file="Vegetation2.txt",header =TRUE)
plot(Veg$BARESOIL, Veg$R, xlab = "BARESOIL", ylab = "R")  #注意自变量和因变量，也可以 plot(x = Veg$BARESOIL, y = Veg$R, xlab = "BARESOIL", ylab = "R")来指定自变量和因变量
plot(x = Veg$BARESOIL, y = Veg$R, xlab = "横坐标", ylab = "纵坐标",
     xlim = c(0,50), ylim =c(0,20),main="标题", pch=16)  #xlim和ylim设定取值范围,pch是指定绘图字符；
?plot  #可以查看很多参数



# ******假如想要实现不同时间使用不同符号来表示则可以按下面操作 ---------------------------------------

unique(Veg$Time)  #查看总共有几个年份
Veg$Time2 <- Veg$Time  #将这些年份生成一个对于pch有效的新的数值向量
Veg$Time2[Veg$Time == 1958] <-1 #[]里面是条件，此处也可以改为Veg$Time2[Veg$Time2 == 1958] <-1，因为在<-左边Time和Time2是对应起来的，<-右边才是条件判断过之后进行的赋值；
Veg$Time2[Veg$Time == 1962] <-2
Veg$Time2[Veg$Time == 1967] <-3
Veg$Time2[Veg$Time == 1974] <-4
Veg$Time2[Veg$Time == 1981] <-5
Veg$Time2[Veg$Time == 1994] <-6
Veg$Time2[Veg$Time == 2002] <-7
Veg$Time2[Veg$Time == 1989] <-8
plot(x = Veg$BARESOIL, y = Veg$R, xlab = "横坐标", ylab = "纵坐标",
     xlim = c(0,50), ylim =c(0,20),main="标题", pch=Veg$Time2)  #我们将不同年份的数据使用不同的符号进行了标示！

#也可以如下操作
Veg$Time3 <- Veg$Time
Veg$Time3
Veg$Time3[Veg$Time <= 1974] <- 1  ##[]里面是条件，此处也可以改为Veg$Time3[Veg$Time3 <= 1974] <- 1，因为在<-左边Time和Time3是对应起来的，<-右边才是条件判断过之后进行的赋值；
Veg$Time3[Veg$Time > 1974] <- 16
plot(x = Veg$BARESOIL, y = Veg$R, xlab = "横坐标", ylab = "纵坐标",
     xlim = c(0,50), ylim =c(0,20),main="标题", pch=Veg$Time3)


# ******改变绘图符号颜色 ----------------------------------------------------------
#在plot函数里面对col选项使用向量
Veg$Time3 <- Veg$Time
Veg$Time3
Veg$Time3[Veg$Time <= 1974] <- 1  ##[]里面是条件，此处也可以改为Veg$Time3[Veg$Time3 <= 1974] <- 1，因为在<-左边Time和Time3是对应起来的，<-右边才是条件判断过之后进行的赋值；
Veg$Time3[Veg$Time > 1974] <- 16

Veg$col3[Veg$Time <= 1974] <- 1  #生成颜色向量1
Veg$col3[Veg$Time > 1974] <- 2   #生成颜色向量2
plot(x = Veg$BARESOIL, y = Veg$R, xlab = "横坐标", ylab = "纵坐标",
     xlim = c(0,50), ylim =c(0,20),main="标题", pch=Veg$Time3, col=Veg$col3)



# ******改变绘图符号尺寸 ----------------------------------------------------------
# 使用cex选项改变尺寸
plot(x = Veg$BARESOIL, y = Veg$R, xlab = "横坐标", ylab = "纵坐标",
     xlim = c(0,50), ylim =c(0,20),main="标题", pch=Veg$Time3, col=Veg$col3, cex=5)

#也可以对cex使用向量，即对不同年份使用不同尺寸来表示
Veg$cex2 <- Veg$Time
unique(Veg$Time)
Veg$cex2[Veg$Time <= 1974] <- 1.5
Veg$cex2[Veg$Time > 1974] <- 4
plot(x = Veg$BARESOIL, y = Veg$R, xlab = "横坐标", ylab = "纵坐标",
     xlim = c(0,50), ylim =c(0,20),main="标题", pch=Veg$Time3, col=Veg$col3, cex=Veg$cex2)


# ******添加一条平滑线 -----------------------------------------------------------
plot(x = Veg$BARESOIL, y = Veg$R, xlab = "横坐标", ylab = "纵坐标",
     xlim = c(0,50), ylim =c(0,20),main="标题", pch=Veg$Time3, col=Veg$col3, cex=Veg$cex2)
##不进行排序直接拟合会画出多条线
M.Loess <- loess(R ~ BARESOIL, data = Veg)  #R ~ BARESOIL表示R可以作为BARESOIL的函数
Fit <- fitted(M.Loess)  #提取拟合值并将其赋值给Fit
lines(Veg$BARESOIL, Fit)  #第一个参数绘制横坐标，第二个参数绘制纵坐标，画线,但是发现是多条线,因为line命令的第一个参数是按照表里面顺序连接点的

#所以我们要先进行排序，然后才可以进行线的拟合
plot(x = Veg$BARESOIL, y = Veg$R, xlab = "横坐标", ylab = "纵坐标", xlim = c(0,50), ylim =c(0,20),main="标题", pch=Veg$Time3, col=Veg$col3, cex=Veg$cex2)
M.Loess <- loess(R ~ BARESOIL, data = Veg)  #R ~ BARESOIL表示R可以作为BARESOIL的函数
Fit <- fitted(M.Loess)  #提取拟合值并将其赋值给Fit
Ord1 <- order(Veg$BARESOIL)
lines(Veg$BARESOIL[Ord1], Fit[Ord1], lwd = 5, lty = 2, col="black")  #lwd表示线的宽度，lty表示线的类型,col可以用“颜色单词”表示，也可以直接用数字表示！
```

# 第六章 循环与函数 

## sort与order

```R
#补充一个知识点
# sort、order函数的分别
# sort()函数是对向量进行从小到大的排序
# order()函数返回的值表示位置

# 举个例子
a <- c(6, 8, 2, 5)
sort(a)
order(a) #order()函数返回的值表示位置，返回值是3，4，1，2表示第三个数排在第一位，第四个数排在第二位，第一个数排在第三位，第二个数排在第四位。


setwd("C:/RBook/")
Owls <- read.table(file="https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/A-beginner's-guide-to-R/Owls.txt",header = TRUE)
names(Owls)
str(Owls)
head(Owls)
dim(Owls)
unique(Owls$Nest)

#想要探索Owls文件中每一个Nest子集里面Arrival Time和Negotiation behaviour(就是指NegPerChick那一列)的关系
#例子1：探索Owls文件中第一个Nest子集(AutavauxTV)里面Arrival Time和Negotiation behaviour的关系
Owls.ATV<-Owls[Owls$Nest=="AutavauxTV",]  #提取子集！这个非常的好理解，可以打开Owls.txt对应着看一下；[]里面是条件，Owls$Nest表示文件中的第一列，
# 但是通过unique(Owls$Nest)函数也可以发现第一列有好几个不同的行，所以=="AutavauxTV",表示要名字为AutavauxTV的这几行！
plot(x = Owls.ATV$ArrivalTime, y = Owls.ATV$NegPerChick,
     xlab = "Arrival Time", ylab = "Negotiation behaviour",
     main =  "AutavauxTV", cex=1.2, col = "red", pch = 16)

#例子2：探索Owls文件中第二个Nest子集(Bochet)里面Arrival Time和Negotiation behaviour的关系
Owls.Bot <- Owls[Owls$Nest=="Bochet",]  #提取Bochest子集
plot(x = Owls.Bot$ArrivalTime, y = Owls.Bot$NegPerChick,
     xlab = "Arrival Time", ylab = "Negotiation behaviour",
     main =  "Bochet", cex=1.2, col = "black", pch = 16)

#例子3：探索Owls文件中第三个Nest子集(Champmartin)里面Arrival Time和Negotiation behaviour的关系
Owls.Cha <- Owls[Owls$Nest=="Champmartin",]  #提取Bochest子集
plot(x = Owls.Cha$ArrivalTime, y = Owls.Cha$NegPerChick,
     xlab = "Arrival Time", ylab = "Negotiation behaviour",
     main =  "Champmartin", cex=1.2, col = "purple", pch = 16)
#                              .
#                              .
#                              .
#                              
#                 这样下去需要重复25遍才能结束！

# Nest.i <- "子集名称"
# Owls.i <- Owls[Owls$Nest==Nest.i,]
# plot(x = Owls.i$ArrivalTime, y = Owls.i$NegPerChick,
#      xlab = "Arrival Time", ylab = "Negotiation behaviour",
#      main =  Nest.i, cex=1.2, col = "purple", pch = 16)


# ******图像的保存 -------------------------------------------------------------
#将上面的第一个保存下来
setwd("D:/生信学习/猪年年尾R学习笔记/R语言初学者指南/AllGraphs")  #设定好图片保存的路径, 有时候会报错，重新将地址复制过来就好了。
jpeg(filename = "AutavauxTV.jpg")  #打开画布，需要先打开画布，然后再plot才可以！
Owls.ATV<-Owls[Owls$Nest=="AutavauxTV",]  #提取子集
plot(x = Owls.ATV$ArrivalTime, y = Owls.ATV$NegPerChick,
     xlab = "Arrival Time", ylab = "Negotiation behaviour",
     main =  "AutavauxTV", cex=1.2, col = "red", pch = 16)  #作图
dev.off()  #关闭画布，不关闭则无法打开图片


# ******构造循环 --------------------------------------------------------------
AllNests <- unique(Owls$Nest)  #使用unique确定Nest名字唯一性；
for (i in 1:27){
  Nest.i <- AllNests[i]  #使Nest.i 和第i个Nest名字对应起来
  Owls.i <- Owls[Owls$Nest == Nest.i,]  #提取第i个子集
  YourFileName <- paste(Nest.i,".jpg",sep="")  #paste可以将变量连接为字符串；使用paste函数对每一个图片的进行命名，可以分别改变一下里面参数，看一下什么变化。
  jpeg(file=YourFileName)  #打开画布，这一步要在plot之前
  plot(x = Owls.i$ArrivalTime, y = Owls.i$NegPerChick,
       xlab = "Arrival Time", ylab = "Negotiation time",
       main =  Nest.i, pch=16)  #画图
  dev.off()  #关闭画布
}


# ******函数 ----------------------------------------------------------------
#对每一个变量制作一个表格给出缺失值和零的个数
#例子1：确定每个变量中缺失值的数量
setwd("C:/RBook")
Veg <- read.table(file = "https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/A-beginner's-guide-to-R/Vegetation2.txt", header = T)
names(Veg)
str(Veg)
head(Veg)
dim(Veg)

NAPerVariable <- function(X1){  #function构造一个函数，函数名字是 NAPerVariable
  D1 <- is.na(X1)  #这里进行一个判断；is.na(X1)生成一个与X1维数相同的布尔矩阵，并将X1矩阵中的缺失值计为TRUE，非缺失值计为FALSE；
  colSums(D1)  #计算每一列元素的和；colSums是R中已有的函数，colsum函数的对象通常为数值矩阵，也可以是布尔矩阵，它会将布尔矩阵中的TRUE计为1，FALSE计为0；并且变量的任何位置出现了空值则colSum函数的输出就为空值，可以通过设定na.rm = TRUE来实现；
}

#X1和D1的解释
# X1是NAPerVariable这个函数的变量，把什么变量给NAPerVariable函数，则X1就是什么
# D1是通过is.na(X1)生成的与X1维数相同的布尔矩阵，并将X1矩阵中的缺失值计为TRUE，非缺失值计为FALSE；

NAPerVariable(Veg[,1:24]) #因为NAPerVariable是刚刚写好的函数，所以直接拿来用，在这里X1就是Veg[,1:24]


#例子2：确定每个变量中缺失值的数量
setwd("c:/RBook/")
Parasite <- read.table(file="CodParasite.txt", header = TRUE)
names(Parasite)
str(Parasite)

NAPerVariable<-function(X1) {
  D <- is.na(X1)
  colSums(D)
}

NAPerVariable(Parasite) #在这里X1就是Parasite


# 例子3：确定每个变量中零值的数量
ZerosPerVariable<-function(X1) {
  D1 =(X1 == 0)  #在这里进行判断，等于0就是TRUE，否则就是FALSE; 这个括号有没有都可以的；
  colSums(D1, na.rm = T)  #通过设定na.rm = TRUE来移除缺失值
}

ZerosPerVariable(Parasite) #在这里X1就是Parasite


#例子4：同时确定每个变量中缺失值和零值的数量
VariableInfo<-function(X1,Choice1) {  #在这里Choice1是一个有两种选择的变量。
  if (Choice1 =="Zeros"){ D1 = X1 == 0 }
  if (Choice1 =="NAs")  { D1 <- is.na(X1)}
  colSums(D1, na.rm = TRUE)
}
#函数 VariableInfo 有两个参数：X1 和 Choice1。X1是数据框，Choice1是一个有两种选择的变量。

VariableInfo(Parasite,"Zeros")  #在这里函数 VariableInfo的两个参数：X1 和 Choice1分别对应着 Parasite 和 "Zeros"
VariableInfo(Parasite,"NAs")
VariableInfo(Parasite,"error test") #因为Choice1只有两种可能性的选择，"Zeros"或者"NAs"，"error test"不符合两种选择中的任何一个，所以会显示error


#例子5：同时确定每个变量中缺失值和零值的数量，并且当输入错误时可以显示特定的提示信息
VariableInfo<-function(X1,Choice1 = "Zeros") {  #这里写的Choice1 = "Zeros"而不仅仅写的Choice1，就相当于设置了默认值为Choice1 = "Zeros"
  if (Choice1 =="Zeros"){ D1 <- X1 == 0 }
  if (Choice1 =="NAs")  { D1 <- is.na(X1)}
  if (Choice1 != "Zeros" & Choice1 != "NAs") {print("What the fuck! You made a typo! You're so stupid!!!")} else {
    colSums(D1, na.rm = TRUE)}
}

VariableInfo(Parasite)  #因为默认值是Choice1 = "Zeros"，所以这里不给choice1的值会按Choice1 = "Zeros"来进行计算。
VariableInfo(Parasite,"Zeros")
VariableInfo(Parasite,"NAs")
VariableInfo(Parasite,"error test")  #若输入错误则会有特定的提示信息！


#例子6：对例子5进行简化，使if数量达到最少
VariableInfo<-function(X1, Choice1 = "Zeros") {
  ifelse (Choice1 =="Zeros", D1 <- (X1 == 0) , D1 <- is.na(X1))  # ifelse替代了前面两个if命令
  if (Choice1 != "Zeros" & Choice1 != "NAs") {print("What the fuck! You made a typo! You're so stupid!!!")} else {
    colSums(D1, na.rm = TRUE)}}

VariableInfo(Parasite)
VariableInfo(Parasite,"NAs")
VariableInfo(Parasite,"Zeros")
VariableInfo(Parasite,"error test")  #若输入错误则会有特定的提示信息！


setwd("C:/RBook/")
Benthic <- read.table("RIKZ.txt",header=T)
Species <- Benthic[,2:76]
n <- dim(Species)
n
sum(Species[1, ], na.rm = TRUE)
sum(Species[2, ], na.rm = TRUE)
sum(Species[3, ], na.rm = TRUE)
sum(Species[4, ], na.rm = TRUE)
#        .
#        .
#        .
# 构造循环来避免该命令写45遍
TA <- vector(length = n[1]) #构造了一个长度为45个向量
TA  #但此时里面45个位置都是空的
for (i in 1:n[1]){
  TA[i] <- sum(Species[i,], na.rm = TRUE)
}

TA

# 其实有更简洁的方式
TA <- rowSums(Species, na.rm = T)  # rowSums函数计算每一行的和
TA


#统计每一行的数值大于0的个数
dim(Species) #总共45行75列
sum(Species[1, ] > 0, na.rm = TRUE)  #Species[1, ] > 0是一个判断式，起到了判断的作用，对Species第一行的75个值进行判断，若该值大于0则为TRUE，返回1，否则为FALSE返回0。然后sum进行了求和，得到的值就是TRUE的个数，即第一行75个数值中满足 >0 这一条件的个数。
sum(Species[2, ] > 0, na.rm = TRUE)
sum(Species[3, ] > 0, na.rm = TRUE)
sum(Species[4, ] > 0, na.rm = TRUE)
#        .
#        .
#        .
# 构造循环来避免该命令写45遍

Richness <- vector(length = n[1]) #构造了一个长度为45的空向量
Richness  #此时里面45个位置都是空的
for (i in 1:n[1]){
  Richness[i] <- sum(Species[i, ] > 0, na.rm = TRUE)
}  #for循环对这45个空位置进行一一填充
Richness

# 其实有更简洁的方式
Richness <- rowSums(Species > 0, na.rm = TRUE) # Species > 0对每一行数据进行判断，若判断成立则返回TRUE，值为1，否则返回FALSE值为0，rowSums函数在这里计算的结果就是满足条件的值的个数。
Richness

RS <- rowSums(Species, na.rm = TRUE)  #因为这里不是判断式，所计算的是每一行的和
RS

prop <- Species / RS
prop
H <- -rowSums(prop * log10(prop), na.rm = TRUE)
H

suppressMessages(install.packages("vegan"))
library(vegan)
H <- diversity(Species)
H

Choice <- "Richness"

if (Choice == "Richness") {
  Index <- rowSums(Species >0 , na.rm = TRUE)}
if (Choice == "Total Abundance") {
  Index <- rowSums(Species, na.rm = TRUE) }
if (Choice=="Shannon") {
  RS <- rowSums(Species, na.rm = TRUE)
  prop <- Species / RS
  Index <- -rowSums(prop * log10(prop), na.rm = TRUE)}


Index.function <- function(Spec, Choice){
  if (Choice == "Richness") {
    Index <- rowSums(Spec>0, na.rm = TRUE)}
  if (Choice == "Total Abundance") {
    Index <- rowSums(Spec, na.rm = TRUE) }
  if (Choice=="Shannon") {
    RS <- rowSums(Species, na.rm = TRUE)
    prop <- Species / RS
    Index <- -rowSums(prop * log10(prop), na.rm = TRUE)}
  list(Index = Index, MyChoice = Choice)
}

```


# 第七章 图形工具 

```R
setwd("C:/RBook/")
BFCases <- read.table(file="BirdFluCases.txt", header = TRUE,sep="\t")
names(BFCases)
dim(BFCases)
str(BFCases)
head(BFCases)
Cases <- rowSums(BFCases[,2:16])  #rowSum对每一行进行求和计算；对BFCases的2到16列的每一行求和！
Cases  #此时还没有名字
names(Cases) <- BFCases[,1]  #names函数将BFCases的第一列内容赋给了Cases，作为Cases的名字；
Cases  #此时有了名字
head(BFCases)

# ******pie函数画饼图 ----------------------------------------------------------------
#Piechart
par(mfrow = c(2,2), mar = c(3, 3, 2, 1)) #mfrow是指面板能生成的图形个数与排版；mar是指每个图形周围空间大小；(改一下参数试下就明白了！)
pie(Cases , main = "Ordinary pie chart")
pie(Cases , col = gray(seq(0.4,1.0,length=6)), clockwise=T, main = "Grey colours")  #clockwise=T是指显示的方向
pie(Cases , col = rainbow(6), clockwise = TRUE, main="Rainbow colours")


# 3D Exploded Pie Chart
library(plotrix)
pie3D(Cases , labels = names(Cases), explode = 0.1, main = "3D pie chart", labelcex=0.6)


# ******par函数对画布进行设置 ------------------------------------------------------------
op <- par(mfrow = c(2,2), mar = c(3, 3, 2, 1))  # mfrow是指面板能生成的图形个数与排版；mar是指每个图形周围空间大小；(改一下参数试下就明白了！)
pie(Cases , main = "Ordinary pie chart")
pie(Cases , col = gray(seq(0.4,1.0,length=6)), clockwise=TRUE, main = "Grey colours")
pie(Cases , col = rainbow(6),clockwise = TRUE, main = "Rainbow colours")
pie3D(Cases , labels = names(Cases ), explode = 0.1, main = "3D pie chart", labelcex=0.6)
par(op)  #图行参数设置保存在了第一行代码的op里面，这里再进行一下par(op)表示结束par设置，就像par从来没有使用过一样。


# ******绘制条形图 -------------------------------------------------------------------
BFDeaths <- read.table(file="BirdFluDeaths.txt", header = TRUE, sep="\t")
Deaths <- rowSums(BFDeaths[,2:16]) #rowSum对每一行进行求和计算；对BFDeaths的2到16列的每一行求和！
Deaths #还没有名字
names(Deaths) <- BFDeaths[,1]  #names函数将BFCases的第一列内容赋给了Cases，作为Cases的名字；
Deaths #有名字了

Counts <- cbind(Cases, Deaths)  #以列的形式结合向量；
Counts

par(mfrow = c(2,2), mar = c(3, 3, 2, 1))  #par函数进行画布设置
barplot(Cases , main = "Bird flu cases")
barplot(Counts)
barplot(t(Counts), col = gray(c(0.5,1))) #gray(c(0.5,1)))是指两个灰度
barplot(t(Counts), beside = TRUE)  #beside是指两个是上下形式还是左右形式；上面那个默认为F
# t函数将数据进行了转置，如果不转置则是分成了Cases和Deaths两组，经过转置之后以年份分为了6组


# ******在条形图上显示均值和标准差 -----------------------------------------------------------
setwd("C:/RBook/")
Benthic <- read.table(file = "RIKZ2.txt", header = TRUE, sep="\t")
dim(Benthic)
head(Benthic)

Bent.M <- tapply(Benthic$Richness, INDEX=Benthic$Beach, FUN=mean)  #Benthic$Richness表示Benthic文件中Richness这一元素！
head(Bent.M)
Bent.sd <- tapply(Benthic$Richness, INDEX=Benthic$Beach, FUN=sd)
head(Bent.sd)
MSD<- cbind(Bent.M, Bent.sd)
MSD

bp <- barplot(Bent.M, xlab = "Beach", ylab = "Richness", col = rainbow(9), ylim = c(0,20))
bp  # bp表示沿x轴每个条形图的中点。
arrows(bp, Bent.M, bp, Bent.M + Bent.sd, lwd = 1.5, angle=90,length=0.1) 
# arrows给图形加标准差垂直线。 bp, Bent.M表示标准差垂直线的起点；bp, Bent.M + Bent.sd表示标准差垂直线的终点，lwd是线宽，angle=90,length=0.1表示标准差垂直线的顶端线与标准差垂直线的角度和顶端线的长度。
box()  #给图形加一个线框框住

Benth.le <- tapply(Benthic$Richness, INDEX=Benthic$Beach, FUN=length)
Bent.se <- Bent.sd / sqrt(Benth.le)  #计算标准误

stripchart(Benthic$Richness ~ Benthic$Beach, vert = TRUE, pch=1, method = "jitter", jit = 1, xlab = "Beach", ylab = "Richness")
points(1:9, Bent.M, pch = 16, cex = 1.5)  #在均值上加点

arrows(1:9, Bent.M, 1:9, Bent.M + Bent.se, lwd = 1.5, angle=90, length=0.1)  #加号表示正的se
      
arrows(1:9, Bent.M, 1:9, Bent.M - Bent.se, lwd = 1.5, angle=90, length=0.1)  #减号表示负的se
       
























#Add lines for sd.
#boxplots


setwd("C:/RBook/")
Owls <- read.table(file = "Owls.txt", header= TRUE, sep="\t")
boxplot(Owls$NegPerChick, main = "Negotiation per chick")
par(mfrow = c(2,2), mar = c(3, 3, 2, 1))  #布置画布
head(Owls)
Owls$LogNeg <- log10(Owls$NegPerChick + 1)  #新加了一列名为LogNeg ，把Owls文件中NegPerChick这一子集提取出来，做相应的运算，赋值给左边.
head(Owls)
boxplot(NegPerChick~SexParent, data = Owls)  #把NegPerChick的数据按照SexParent进行画图
boxplot(NegPerChick~FoodTreatment, data = Owls)  #把NegPerChick的数据按照FoodTreatment进行画图
boxplot(NegPerChick~SexParent * FoodTreatment,data = Owls)  #把NegPerChick的数据按照SexParent 和 FoodTreatment进行画图
boxplot(NegPerChick~SexParent * FoodTreatment, names = c("F/Dep","M/Dep","F/Sat","M/Dep"),data = Owls)#把NegPerChick的数据按照SexParent 和 FoodTreatment进行画图，并进行命名；



# ******在条形图上加标签 ----------------------------------------------------------------
par(mar = c(2,2,3,3))
boxplot(NegPerChick~Nest, data = Owls, axes = F, ylim = c (-3.5, 9))  #axes表示轴线
axis(2, at = c(0, 2, 4, 6, 8))  #1表示行，2表示列，在图片左边生成一个轴，axis的第一个参数是位置；at参数指的是要标记的刻度；
text(x = 1:27, y = -2, labels = levels(Owls$Nest),cex=0.75, srt=60)     # y=-2表示该标签在y轴的相对位置，放置标签，cex表示字体大小，srt表示倾斜角度！
levels(Owls$Nest)   # 和names(table(Owls$Nest))一样的结果
    

#Boxplot for RIKZ data
setwd("C:/RBook/")
Benthic <- read.table(file = "RIKZ2.txt", header= TRUE, sep="\t")
head(Benthic)
names(Benthic)
Bentic.n <- tapply(Benthic$Richness, Benthic$Beach, FUN =length) #对文件Benthic，以Beach对Richness进行分组，统计每组数据个数
Bentic.n
bp <- boxplot(Richness ~ Beach, data = Benthic, col = "grey",  
              xlab = "Beach", ylab = "Richness")  #boxplot函数可以将信息存储在一个list里面，也就是此处的bp包含好几个变量！
bp
str(bp)

bpmid <- bp$stats[2, ] + (bp$stats[4,] - bp$stats[2,]) / 2
bpmid
text(1:9, bpmid, Bentic.n, col = "white", font = 2)  #x=1:9是向量的长度，y=bpmid表示9元素向量的位置，labels =Bentic.n表示9元素向量的内容
?text
#心得！
# 对于一个函数没有必要去背，比如这里text(1:9, bpmid, Bentic.n, col = "white", font = 2) 是什么意思就很难背下来每一个参数对应哪一个，只要?text一下就可以很容易的对应上
# text(x, y = NULL, labels = seq_along(x$x), adj = NULL,
#      pos = NULL, offset = 0.5, vfont = NULL,
#      cex = 1, col = NULL, font = NULL, ...)  #只要一对应就好了，知道1:9, bpmid, Bentic.n,分别对应着x，y，labels，然后再在帮助文档看一下什么意思就可以了。



# ******点图 ----------------------------------------------------------------------
#很重要的一点，这个点图上下的摆动是随机分布的(这种随机是指限制在组内的随机)，但是左右的摆动是按照他的刻度来的！
?dotchart
setwd("C:/RBook/")
Deer <-read.table("Deer.txt", header = TRUE, sep="\t")


par(mfrow=c(1,2))  #布置画布
dotchart(Deer$LCT, xlab="Length (cm)", ylab = "Observation number")

dotchart(Deer$LCT, groups = factor(Deer$clas1_4))  #groups选项允许数据根据分类变量进行分组！因为Sex变量里面有缺失值，所以这一条命令执行不成功。
Deer$clas1_4
Isna <- is.na(Deer$clas1_4)  #is.na是检测缺失值的函数，若返回值为TRUE则为缺失值，FALSE则为非缺失值；
!Isna  #符号！将Isna进行了一个颠倒。颠倒了之后下一步的作图只会去对TRUE的进行绘图。

dotchart(Deer$LCT[!Isna], groups = factor(Deer$clas1_4[!Isna]), 
         xlab = "Length (cm)", ylab = "Observation number grouped by sex")  


setwd("C:/RBook/")
Benthic <- read.table(file = "RIKZ2.txt", header= TRUE,sep="\t")
head(Benthic)
sum(Benthic$Beach)  #因为Benthic$Beach是数值型向量，所以可以求和；

Benthic$fBeach <- factor(Benthic$Beach)  #factor将数值型向量变为了因子。可以通过sum函数发现Benthic$Beach可以求和，Benthic$fBeach却不可以；
sum(Benthic$fBeach)   #因为Benthic$Beach是因子，所以不能求和；

par(mfrow=c(1,2))
dotchart(Benthic$Richness,groups=Benthic$fBeach,  #如果省略掉Benthic$fBeach <- factor(Benthic$Beach) 这一步，则groups=Benthic$fBeach就应该写成groups=factor(Benthic$Beach)
         xlab="Richness", ylab = "Beach")

Bent.M<-tapply(Benthic$Richness,Benthic$Beach,FUN = mean)
Bent.M

dotchart(Benthic$Richness,groups=Benthic$fBeach,
         gdata = Bent.M, gpch=19, xlab="Richness", ylab="Beach")  # gdata用来表示一个值，这里指的平均值

legend("bottomright",c("values","mean"),pch=c(1,19),bg="red")  #legend函数添加图例，bg表示背景色的颜色


# ******plot函数 ------------------------------------------------------------------
setwd("C:/RBook/")
Benthic <- read.table(file = "RIKZ2.txt", header= TRUE,sep="\t")
Benthic$fBeach <- factor(Benthic$Beach)
plot(Benthic$Richness,Benthic$fBeach)
par(mfrow = c(2,2), mar = c(4,4,2,2) +.5)

plot(y = Benthic$Richness, x = Benthic$NAP,
     xlab = "Mean high tide (m)", ylab = "Species richness",
     main = "Benthic data")

M0 <- lm(Richness ~ NAP, data = Benthic)  #lm利用线性回归建立模型，结果存储在列表M0里面
abline(M0)  #abline函数添加拟合线

# ******plot函数中type，axes函数选项 --------------------------------------------------
plot(y = Benthic$Richness, x = Benthic$NAP,
     type = "n", axes = FALSE,  #type表示图形的类型,n就表示不画图；axes表示轴线
     xlab = "Mean high tide", ylab = "Species richness")
?plot  #可以看到，如果将type = "n"换成type = "p"就会出图；

points(y = Benthic$Richness, x = Benthic$NAP)

plot(y = Benthic$Richness, x = Benthic$NAP,
     type = "n", axes = FALSE,
     xlab = "Mean high tide", ylab = "Species richness",
     xlim = c(-1.75,2), ylim = c(0,20))
points(y = Benthic$Richness, x = Benthic$NAP)

# ******axis命令绘制轴线 ------------------------------------------------------------
axis(2, at = c(0, 10, 20), tcl = 1)  #axis第一个参数2表示在左边添加轴，at表示添加的刻度；tcl表示z轴上刻度的长短；
axis(1, at = c(-1.75,0,2), labels = c("Sea","Water line","Dunes") )


# ******点/文本/线的添加 -------------------------------------------------------------
setwd("C:/RBook/")
Birds <- read.table(file="loyn.txt", header= TRUE, sep="\t")
Birds$LOGAREA<- log10(Birds$AREA)
Birds$fGRAZE <- factor(Birds$GRAZE)

M0 <- lm(ABUND~ LOGAREA + fGRAZE, data = Birds)
summary(M0)

plot(x = Birds$LOGAREA, y = Birds$ABUND, xlab="Log transformed AREA", ylab="Bird abundance")


# ******改变字体和字体大小 -------------------------------------------------------------
windowsFonts()  #查看目前已经安装好的字体类型
title("Fitted model", cex.main = 2, family = "sans", font.main = 1)  #family指字体类型，font.main指字体大小

#计算五个拟合值
LAR<-seq(-1, 3, by = 0.1)

ABUND1 <- 15.7 +  7.2 * LAR
ABUND2 <- 16.1 +  7.2 * LAR
ABUND3 <- 15.5 +  7.2 * LAR
ABUND4 <- 14.1 +  7.2 * LAR
ABUND5 <- 3.8 +  7.2 * LAR

#把拟合值作为线添加到图形上
lines(LAR, ABUND1, lty = 1, lwd = 1, col =1)
lines(LAR, ABUND2, lty = 2, lwd = 2, col =2)
lines(LAR, ABUND3, lty = 3, lwd = 3, col =3)
lines(LAR, ABUND4, lty = 4, lwd = 4, col =4)
lines(LAR, ABUND5, lty = 5, lwd = 5, col =5)

legend.txt <- c("Graze 1","Graze 2","Graze 3","Graze 4","Graze 5")


# ******图例添加 -----------------------------------------------------------------
legend("topleft",  #topleft表示位置
       legend = legend.txt,  #要标注的内容
       col = c(1,2,3,4,5),  #拟合线的颜色
       lty = c(1,1,1,1,5),  #图例线的形式，lty=1表示实心；
       lwd = c(1,2,3,4,5),  #图例线条的粗细
       bty = "o",  #添加围绕图例的盒子
       cex = 0.8  #图例文本大小
)


# ******添加特殊符号 ----------------------------------------------------------------
setwd("C:/RBook/")
Whales <- read.table(file="TeethNitrogen.txt", header= TRUE)
head(Whales)

N.Moby <- Whales$X15N[Whales$Tooth == "Moby"]  #因为[,]的逗号左边是行，右边是列；但是要求被取值的内容不能是一维度，否则哪里来的行和列？因为此处Whales$X15N是一维数据，所以[]中不能加逗号；
N.Moby

# 强烈注意：
# 关于[]取子集什么时候加逗号，什么时候不加逗号
# 因为逗号是用来分隔行和列的，逗号前的为行，逗号后的为列；所有加逗号取子集的前提是被取值的内容不是一维数据，有行有列是二维啊；所以，一维数据取子集不用加逗号，因为一维没有行列；

# N.Moby2 <- Whales[Whales$Tooth == "Moby",]  #因为[,]的逗号左边是行，右边是列；但是要求被取值的内容不能是一维度，否则哪里来的行和列？
# N.Moby2


Age.Moby <- Whales$Age[Whales$Tooth == "Moby"]
plot(x = Age.Moby, y = N.Moby, xlab = "Age", ylab = expression(paste(delta^{15}, "N")))


# ******pairs 函数生成多面板的散点图 -------------------------------------------------------
setwd("C:/RBook/")
Benthic <- read.table(file = "RIKZ2.txt", header= TRUE)
head(Benthic)
class(Benthic)
pairs(Benthic[, 2:9])  #等同于plot(Benthic[,2:9])，因为Benthic是一个数据框，plot函数能够识别它并能调用函数plot.data.frame
#生成的图片对角线显示的是变量的名称，表示对角线上方或下方面板的x轴变量名称，同时还表示对角线左方或右方面板y轴的变量名称
#即每一个图片都可以画一个横轴，也可以画一个纵轴，会跟对角线有交点，交点就是x变量和y变量
#这种多组图有一半的图是多余的，因为每幅图都会出现两次；分别出现在对角线上下方，但坐标轴是颠倒的。

pairs(Benthic[, 2:9], diag.panel = panel.hist, upper.panel = panel.smooth, lower.panel = panel.cor)



# 皮尔逊相关系数应用于pairs函数 -------------------------------------------------
panel.hist <- function(x, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(usr[1:2], 0, 1.5) )
  h <- hist(x, plot = FALSE)
  breaks <- h$breaks; nB <- length(breaks)
  y <- h$counts; y <- y/max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col="cyan", ...)
}


panel.cor <- function(x, y, digits=2, prefix="", cex.cor)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- abs(cor(x, y))
  txt <- format(c(r, 0.123456789), digits=digits)[1]
  txt <- paste(prefix, txt, sep="")
  if(missing(cex.cor)) cex <- 0.8/strwidth(txt)
  text(0.5, 0.5, txt, cex = cex * r)
}

pairs(Benthic[, 2:9], diag.panel = panel.hist,
      upper.panel = panel.smooth, lower.panel = panel.cor)

# pairs函数只能显示双向关系，显示多项关系需要coplot



# coplot 显示多项关系 -----------------------------------------------------------

# * coplot显示三向关系 ----------------------------------------------------------
setwd("C:/RBook/")
Benthic <- read.table(file = "RIKZ2.txt", header= TRUE, sep="\t")

#对于不同Beach绘制Richness对于NAP的散点图；y~x的顺序确定自变量和因变量；as.factor(Beach)把海滩变量作为条件生成图形；
coplot(Richness ~ NAP | as.factor(Beach), pch=19, data = Benthic)  

#对于不同grainsize绘制Richness对于NAP的散点图；
coplot(Richness ~ NAP | grainsize, pch=19, data = Benthic)  

# * coplot 每个面板里加上一条回归线 ---------------------------------------------------
# panel.lm定义在每个面板里如何显示数据
panel.lm = function(x, y, ...) {
  tmp<-lm(y~x,na.action=na.omit)  #线性回归函数lm用来把数据暂时存储在变量tmp中，该分析中任何NAs都将被忽略；
  abline(tmp, lwd = 2)  #abline函数绘制线
  points(x,y, ...)}  #points绘制点

coplot(Richness ~ NAP | as.factor(Beach), pch=19, panel = panel.lm, data=Benthic) #对于不同Beach绘制Richness对于NAP的散点图；
coplot(Richness ~ NAP | as.factor(Beach), pch=19, span =1, panel = panel.smooth, data=Benthic)


# * coplot 显示四向关系 ---------------------------------------------------------
# panel.lm定义在每个面板里如何显示数据
panel.lm = function(x, y, ...) {
  tmp<-lm(y~x,na.action=na.omit)  #线性回归函数lm用来把数据暂时存储在变量tmp中，该分析中任何NAs都将被忽略；
  abline(tmp, lwd = 2)  #abline函数绘制线
  points(x,y, ...)}  #points绘制点

#PH对应于SDI，海拔和森林覆盖之间的关系
setwd("C:/RBook/")
pHEire<-read.table(file="SDI2003.txt", header=TRUE, sep="\t")
pHEire$LOGAlt <- log10(pHEire$Altitude)
pHEire$fForested <- factor(pHEire$Forested)
coplot(pH ~ SDI | LOGAlt * fForested, panel=panel.lm,data=pHEire)
coplot(pH ~ SDI | LOGAlt * fForested, panel=panel.lm,data=pHEire, number=2)  #LOGAlt区间的位置和数目可以通过number来调控；


# * 增加coplot的修饰 -----------------------------------------------------------
panel.lm2=function(x,y,col.line="black",lwd=par("lwd"),
                   lty=par("lwt"), ...){
  tmp<-lm(y~x,na.action=na.omit)
  points(x,y, ...)
  abline(tmp,col=col.line,lwd=lwd,lty=lty)}


CI <- co.intervals(pHEire$LOGAlt,3)
GV <- list(CI,c(2,1))

pHEire$Temperature

#根据不同的温度，将点变成不同颜色
pHEire$Temp2 <- cut(pHEire$Temperature, breaks = 2)  #breaks = 2，所以cut函数将温度数据分成两部分；
pHEire$Temp2
pHEire$Temp2.num <- as.numeric(pHEire$Temp2)  #将pHEire$Temp2从因子转为数值，因为因子不能作为色彩和灰度值；
pHEire$Temp2.num
coplot(pH ~ SDI | LOGAlt * fForested, panel=panel.lm, data=pHEire, given.values = GV, cex=1.5,pch=19, col=gray(pHEire$Temp2.num/3))


# 图形排列 --------------------------------------------------------------------
#mfrow命令可以在一个屏幕上绘制多个图形；而layout可以生成复杂的图形排列；
MyLayOut <- matrix(c(2,0,1,3), nrow = 2, ncol=2, byrow = TRUE)  #matrix函数生成一个矩阵，2行，2列，按行排列；
MyLayOut
nf <- layout(mat = MyLayOut,widths = c(3, 1),  # widths 指定列宽；
             heights = c(1, 3), respect = TRUE)  # height 指定行高，respect = TRUE确保垂直方向上的一个单位与水平方向上的一个单位相同；

layout.show(nf)

xrange<-c(min(Benthic$NAP),max(Benthic$NAP))
yrange<-c(min(Benthic$Richness),max(Benthic$Richness))

#生成第一个图形
par(mar=c(4,4,2,2))
plot(Benthic$NAP,Benthic$Richness,xlim=xrange,ylim=yrange, xlab = "NAP", ylab="Richness")

#生成第二个图形
par(mar=c(0,3,1,1))
boxplot(Benthic$NAP,horizontal=TRUE,axes=F, frame.plot=F,ylim=xrange,space=0)

#生成第三个图形
par(mar=c(3,0,1,1))
boxplot(Benthic$Richness,axes=F,ylim=yrange,space=0,horiz=TRUE)



# —— ----------------------------------------------------------------------

# 格包简介 --------------------------------------------------------------------

setwd("C:/RBook")
Env <- read.table(file="RIKZENV.txt",header = TRUE)
names(Env)
str(Env)
sum(is.na(Env))  #2975 NAs

## where are the NAs?

# Stations in each area
table(Env$Station,Env$Area)

tapply(Env$SAL,list(Env$Station,Env$Year,Env$Month),length)
tapply(Env$SAL,list(Env$Station,Env$Month),length)
tapply(Env$SAL,list(Env$Area,Env$Month),length)

# count values
ndata<-function(x) sum(!is.na(x))
tapply(Env$SAL,list(Env$Station,Env$Month),ndata)
tapply(Env$SAL,list(Env$Area,Env$Month),ndata)

# count NAs
nnas<-function(x) sum(is.na(x))
tapply(Env$SAL,list(Env$Station,Env$Month),nnas)
tapply(Env$SAL,list(Env$Area,Env$Month),nnas)



# 多面板散点图：xyplot -----------------------------------------------------------
library(lattice)
Env$MyTime<-Env$Year+Env$dDay3/365

#根据station不同来绘制SAL对MyTime的图形；
xyplot(SAL ~ MyTime | factor(Station), type="l",  # y轴 ~ x轴，管道命令后为条件变量(此处为station)，条件变量通常为因子；
       strip = function(bg, ...)  #...表示将信息传递给其他特定的函数
         strip.default(bg = 'white', ...),  #对每一个带使用白色背景
       col.line=1,  #图形线条颜色
       data = Env)

xyplot(SAL ~ MyTime | factor(Station), data = Env)
xyplot(SAL ~ MyTime | factor(Station), type="l", strip = TRUE, col.line=1, data = Env)
xyplot(SAL ~ MyTime | factor(Station), type="l", strip = FALSE, col.line=1, data = Env) #查看strip功能，strip用来绘制带状；


# 多面板盒型图：bwplot -----------------------------------------------------------
bwplot(SAL ~ factor(Month) | Area,
       strip = strip.custom(bg = 'white'),
       cex = .5, layout = c(2, 5),
       data = Env, xlab = "Month", ylab = "Salinity",
       par.settings = list(
         box.rectangle = list(col = 1),
         box.umbrella  = list(col = 1),
         plot.symbol   = list(cex = .5, col = 1)))

bwplot(SAL ~ factor(Month) | Area, layout = c(2, 5), data = Env) #若采用黑白作图，则上面的代码可以简化为这个；



# 多面板点图：dotplot -----------------------------------------------------------
dotplot(factor(Month) ~ SAL  | Station,
        subset = Area=="OS", jitter.x = TRUE,  #subset是用来选定全部数据的一个子集；jitter.x = TRUE表示当多个观察值在同一月份相同的时候，在水平方向增加一些变化；
        data = Env, strip = strip.custom(bg = 'white'),
        col = 1, cex = 0.5, ylab = "Month",
        xlab = "Salinity")

dotplot(SAL ~ factor(Month) | Station,    
        subset = Area=="OS", jitter.x = T,
        data = Env, strip = strip.custom(bg = 'white'),
        col = 1, cex = 0.5, xlab = "Month",
        ylab = "Salinity")    #与上一个相比将x轴y轴对调一下；



# 多面板直方图: histogram -------------------------------------------------------
histogram( ~ SAL | Station, data = Env,
           subset = Area=="OS", layout = c(1,4),  #layout里面为1列2行的布局，与先行后列不同
           nint = 30, xlab = "Salinity", strip = FALSE,  #nint是条形的数目
           strip.left = TRUE, ylab="Frequencies")  #通过strip = FALSE, strip.left = TRUE将带状移到了面板左边；


#Example 1
xyplot(SAL ~ Month | Year, data = Env,  
       type = c("p"), subset = (Station =="GROO"),  #type有三个函数，分别是p，g，smooth；相当于函数执行了panel.xyplot，panel.grid，panel.loess
       xlim = c(0, 12), ylim = c(0, 30),pch = 19,
       panel = function (...){
         panel.xyplot(...)  #画出数据点
         panel.grid(..., h = -1, v = -1)  #panel.grid加网格线，h和v为正值表示水平与垂直网格线的数目；若为负值则网格与轴坐标对其；
         panel.loess(...)}, span = 0.9)  #panel.loess加拟合线，span表示拟合线的平滑程度；

#Example 2
#使用不同的颜色和大一点的点来表示潜在异常值，方法1和方法2是殊途同归
setwd("C:/RBook")
library(lattice)
Env <- read.table(file="RIKZENV.txt",header = TRUE)
#方法1
dotplot(factor(Month) ~ SAL | Station, pch = 16,
        subset = (Area=="OS"), data = Env,
        ylab = "Month", xlab = "Salinity",
        panel = function(x,y,...) {
          q1 <- summary(x,na.rm=TRUE)[2]
          q3 <- summary(x,na.rm=TRUE)[5]
          R <- q3 - q1
          L <- median(x,na.rm=TRUE) - 3 * (q3 - q1)
          MyCex <- rep(0.4,length(y))
          MyCol <- rep(1,length(y))
          MyCex[x < L] <- 1.5
          MyCol[x < L] <- 2
          panel.dotplot(x,y, cex = MyCex, col = MyCol, ...)})

# 方法2
dotplot(factor(Month) ~ SAL | Station, pch = 16,
        subset = (Area=="OS"), data = Env,
        ylab = "Month", xlab = "Salinity",
        panel = function(x, y, ...) {
          Q <- quantile(x, c(0.25, 0.5, 0.75) ,  #
                        na.rm = TRUE)
          R <- Q[3] - Q[1]
          L <- Q[2] - 3 * (Q[3] - Q[1])  #L为盐度数据的截止水平，即中位数减去第三四分位数和第一四分位数差的三倍
          MyCex <- rep(0.4, length(y))
          MyCol <- rep(1, length(y))
          MyCex[x < L] <- 1.5  #当盐度低于标准修改点的尺寸
          MyCol[x < L] <- 2    #当盐度低于标准修改点的颜色
          panel.dotplot(x, y, cex = MyCex, 
                        col = MyCol, ...)})



# 多面板 PCA 分析双标图 -----------------------------------------------------------
setwd("C:/RBook")
Sparrows<-read.table(file="Sparrows.txt", header=TRUE)
names(Sparrows)
str(Sparrows)
library(lattice)
xyplot(Wingcrd ~ Tarsus | Species * Sex,  #管道命令后面是两个条件变量
       xlab = "Axis 1", ylab = "Axis 2", data = Sparrows,
       xlim = c(-1.1, 1.1), ylim = c(-1.1, 1.1),
       panel = function(subscripts, ...){
         zi <- Sparrows[subscripts, 3:8]
         di <- princomp(zi, cor = TRUE)
         Load <- di$loadings[, 1:2]
         Scor <- di$scores[, 1:2]
         panel.abline(a = 0, b = 0, lty = 2, col = 1)
         panel.abline(h = 0, v = 0, lty = 2, col = 1)
         for (i in 1:6){
           llines(c(0, Load[i, 1]), c(0, Load[i, 2]), 
                  col = 1, lwd = 2)
           ltext(Load[i, 1], Load[i, 2], 
                 rownames(Load)[i], cex = 0.7)}
         sc.max <- max(abs(Scor))
         Scor <- Scor / sc.max
         panel.points(Scor[, 1], Scor[, 2], pch = 1,
                      cex = 0.5, col = 1)
       })



# 三维点图/表面图/等高线图 -----------------------------------------------------------
setwd("C:/RBook")
library(lattice)
Env <- read.table(file="RIKZENV.txt",header = TRUE)   
cloud(CHLFa ~ T * SAL | Station, data = Env,
      screen = list(z = 105, x = -70),
      ylab = "Sal", xlab = "T", zlab = "Chl. a",
      ylim = c(26,33),
      subset = (Area=="OS"),
      scales = list(arrows = FALSE))




# 常见问题 --------------------------------------------------------------------


# * 改变面板顺序 ----------------------------------------------------------------
setwd("C:/RBook")
Hawaii <- read.table("waterbirdislandseries.txt", header = TRUE)
library(lattice)
names(Hawaii)
Birds <- as.vector(as.matrix(Hawaii[,2:9]))  #as.vector命令不能应用于数据框；所以as.matrix命令首先将数据转化为一个矩阵，然后再由as.vector将其转化为一个长向量！
Time <- rep(Hawaii$Year, 8)  #rep函数的作用是生成一个单独的长向量；
MyNames <- c("Stilt_Oahu","Stilt_Maui","Stilt_Kauai_Niihau","Coot_Oahu","Coot_Maui","Coot_Kauai_Niihau","Moorhen_Oahu","Moorhen_Kauai")
ID <- rep(MyNames, each = 48)

xyplot(Birds ~ Time|ID, ylab = "Bird abundance", layout = c(3, 3), type = "l", col = 1)

#通过改变levels顺序就可以改变这些面板的顺序；
ID2 <- factor(ID, levels=c("Stilt_Oahu","Stilt_Kauai_Niihau","Stilt_Maui","Coot_Oahu","Coot_Kauai_Niihau","Coot_Maui","Moorhen_Oahu","Moorhen_Kauai"))
xyplot(Birds ~ Time|ID2, ylab = "Bird abundance",layout = c(3, 3), type = "l", col = 1)


# * 改变坐标轴界限刻度 -------------------------------------------------------------
xyplot(Birds ~ Time|ID2, ylab = "Bird abundance",
       layout = c(3, 3), type = "l", col = 1,
       scales = list(x = list(relation = "same"),
                     y = list(relation = "free"),
                     tck=-1))  #tck是刻度，负朝里，正朝外；数字代表长短

# * 一个面板中绘制多条线 ------------------------------------------------------------
#将同一种鸟的所有时间序列陈列在一个单独的面板中
Species <-rep(c("Stilt","Stilt","Stilt","Coot","Coot","Coot","Moorhen","Moorhen"),each = 48)
xyplot(Birds ~ Time|Species, ylab = "Bird abundance",
       layout = c(2, 2), type = "l", col = 1,
       scales = list(x = list(relation = "same"),
                     y = list(relation = "free")),
       groups = ID, lwd=c(1,2,3))




# 更新图形 --------------------------------------------------------------------
MyPlot <- xyplot(Birds ~ Time|Species, ylab = "Bird abundance",
                 layout = c(2, 2), type = "l", col = 1,
                 scales = list(x = list(relation = "same"),
                               y = list(relation = "free")),
                 groups = ID, lwd=c(1,2,3))

print(MyPlot)
update(MyPlot, layout=c(3,3)) #对象的很多属性可以通过update函数来修改！可以保持原始图不变。

```

# GitHub文件托管和R读取托管文件

![image](https://github.com/user-attachments/assets/9a9f1bfc-cf2f-4e39-98ad-b9a894c9db95)


![image](https://github.com/user-attachments/assets/54d20db2-bc1a-46e4-b142-bc088e4be369)


# 常用生信SCI图代码汇总（R语言）
其实就是从这里来的[常用生信SCI图代码汇总（R语言）](https://zhuanlan.zhihu.com/p/549449748)，但是怕网站丢失所以自己从头到尾照着模仿了一遍。

## 热图

```R

library(pheatmap) #加载R包

# 1，读取热图数据文件
df = read.table("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/heatmap/data.heatmap.txt", #这里是余顺太Github文件托管。
                header = T, # 是否有标题
                sep = "\t", # 分隔符是Tab键
                row.names = 1, # 指定第一列是行名
                fill=T) # 是否自动填充，一般选择是
# （可选）读取分组数据文件
dfSample = read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/heatmap/sample.class.txt",header = T,row.names = 1,fill = T,sep = "\t")
dfGene = read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/heatmap/gene.class.txt",header = T,row.names = 1,fill = T,sep = "\t")

# 2，绘图
pheatmap(df, 
         annotation_row=dfGene, # （可选）指定行分组文件
         annotation_col=dfSample, # （可选）指定列分组文件
         show_colnames = TRUE, # 是否显示列名
         show_rownames=TRUE,  # 是否显示行名
         fontsize=6, # 字体大小
         color = colorRampPalette(c('#0000ff','#ffffff','#ff0000'))(50), # 指定热图的颜色
         annotation_legend=F, # 是否显示图例
         border_color=NA,  # 边框颜色 NA表示没有
         scale="row",  # 指定归一化的方式。"row"按行归一化，"column"按列归一化，"none"不处理
         cluster_rows = TRUE, # 是否对行聚类
         cluster_cols = TRUE # 是否对列聚类
)

# 更多参数可以输入 ?pheatmap 查看
```
## PCA

```R

# 加载R包，没有安装请先安装  install.packages("包名") 
library(ggplot2)
library(ggbiplot)
library(devtools)


# 读取PCA数据文件
df = read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/PCA/PCA_data.txt",# 这里读取了网络上的demo数据，将此处换成你自己电脑里的文件
                header = T,    # 指定第一行是列名
                row.names = 1  # 指定第一列是行名
)
df=t(df) # 对数据进行转置，如果想对基因分组则不用转置

# 读取样本分组数据文件
dfGroup = read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/PCA/PCA_sample.class.txt",
                     header = T,
                     row.names = 1
)

# PCA计算
pca_result <- prcomp(df,
                     scale=T  # 一个逻辑值，指示在进行分析之前是否应该将变量缩放到具有单位方差
)

# 绘图
ggbiplot(pca_result, 
         var.axes=F,            # 是否为变量画箭头
         obs.scale = 1,         # 横纵比例 
         groups = dfGroup[,1],  # 添加分组信息，为分组文件的第一列
         ellipse = T,           # 是否围绕分组画椭圆
         circle = F)+ 
  geom_text(                      # geom_text一个在图中添加标注的函数
    aes(label=rownames(df)),   # 指定标注的内容为数据框df的行名
    vjust=1.5,            # 指定标记的位置，vjust=1.5 垂直向下1.5个距离。   负数为位置向上标记，正数为位置向下标记
    size=3                # 标记大小
  )

# 更多请 ?ggbiplot 获取帮助
```

## 3D PCA

```R

# 加载R包，没有安装请先安装  install.packages("包名") 
library(ggplot2)
library(ggbiplot)
library(devtools)
library(scatterplot3d)


# 读取PCA数据文件
df = read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/PCA/PCA_data.txt",# 这里读取了网络上的demo数据，将此处换成你自己电脑里的文件
                header = T,    # 指定第一行是列名
                row.names = 1  # 指定第一列是行名
)
df=t(df) # 对数据进行转置，如果想对基因分组则不用转置

# 读取样本分组数据文件
dfGroup = read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/PCA/PCA_sample.class.txt",
                     header = T,
                     row.names = 1
)


# PCA计算
pca_result <- prcomp(df,
                     scale=T  # 一个逻辑值，指示在进行分析之前是否应该将变量缩放到具有单位方差
)
pca_result$x<-data.frame(pca_result$x)
# 设置颜色，有几个分组就写几个颜色
colors <- c("red","blue","green")
colors <- colors[as.numeric(as.factor(dfGroup[,1]))]
# 设置点形状，仅供参考
# shape<-16:18
# shape<-shape[as.numeric(as.factor(dfGroup[,1]))]

# 计算PC值，并替换列名，用来替换坐标轴上的标签
pVar <- pca_result$sdev^2/sum(pca_result$sdev^2)
pVar = round(pVar,digits = 3)
colnames(pca_result$x)[1:3] = c(
  paste0("PC1 (",as.character(pVar[1] * 100 ),"%)"),
  paste0("PC2 (",as.character(pVar[2] * 100 ),"%)"),
  paste0("PC3 (",as.character(pVar[3] * 100 ),"%)")
)

# 绘图
s3d <- scatterplot3d(pca_result$x[,1:3],
                     pch = 16,       # 点形状
                     color=colors,   # 点颜色
                     cex.symbols = 2 # 点大小
)
# 设置图例
legend("top",
       legend = unique(dfGroup[,1]),
       col =  c("red","blue","green"),
       pch = 16,
       inset = -0.1,
       xpd = TRUE,
       horiz = TRUE)
# 设置文字标注
text(s3d$xyz.convert(pca_result$x[,c(1,2,3)] + 2),
     labels = row.names(pca_result$x),
     cex = 0.8,col = "black")

```

## 可旋转3D PCA

```R

library(ggplot2)
library(ggbiplot)
library(devtools)
library(scatterplot3d)
library(plotly)

# 读取PCA数据文件
df = read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/PCA/PCA_data.txt",
                header = T,
                row.names = 1
)
df = t(df)  # 对数据进行转置

# 读取样本分组数据文件
dfGroup = read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/PCA/PCA_sample.class.txt",
                     header = T,
                     row.names = 1
)

# PCA计算
pca_result <- prcomp(df, scale = TRUE)
pca_result$x <- data.frame(pca_result$x)

# 设置颜色
colors <- c("red", "blue", "green")
colors <- colors[as.numeric(as.factor(dfGroup[, 1]))]

# 计算PC值并替换列名
pVar <- pca_result$sdev^2 / sum(pca_result$sdev^2)
pVar <- round(pVar, digits = 3)
colnames(pca_result$x)[1:3] <- c(
  paste0("PC1 (", as.character(pVar[1] * 100), "%)"),
  paste0("PC2 (", as.character(pVar[2] * 100), "%)"),
  paste0("PC3 (", as.character(pVar[3] * 100), "%)")
)


# 转换为数据框供plotly使用
pca_data <- cbind(pca_result$x[, 1:3], Group = dfGroup[, 1])

# 重命名列名以便于 plotly 使用
colnames(pca_data) <- c("PC1", "PC2", "PC3", "Group")

# 使用 plotly 生成 3D PCA 图并启用旋转
p <- plot_ly(pca_data, x = ~PC1, y = ~PC2, z = ~PC3, color = ~Group, colors = colors, type = "scatter3d", mode = "markers") %>%
  layout(scene = list(xaxis = list(title = paste0("PC1 (", pVar[1] * 100, "%)")),
                      yaxis = list(title = paste0("PC2 (", pVar[2] * 100, "%)")),
                      zaxis = list(title = paste0("PC3 (", pVar[3] * 100, "%)"))))
p  # 显示交互式 3D 图


```




## 火山图

```R
# 加载R包，没有安装请先安装  install.packages("包名") 
library(ggplot2)
library(ggrepel)  #用于标记的包

# 读取火山图数据文件
data = read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/Volcano/Volcano.txt",# 这里读取了网络上的demo数据，将此处换成你自己电脑里的文件
                  header = T    # 指定第一行是列名
)
# 建议您的文件里对应的名称跟demo数据一致，这样不用更改后续代码中的变量名称

FC = 1.5 # 用来判断上下调，一般蛋白质组的项目卡1.5
PValue = 0.05 #用来判断上下调

# 判断每个基因的上下调,往数据框data里新增了sig列
data$sig[(-1*log10(data$PValue) < -1*log10(PValue)|data$PValue=="NA")|(log2(data$FC) < log2(FC))& log2(data$FC) > -log2(FC)] <- "NotSig"
data$sig[-1*log10(data$PValue) >= -1*log10(PValue) & log2(data$FC) >= log2(FC)] <- "Up"
data$sig[-1*log10(data$PValue) >= -1*log10(PValue) & log2(data$FC) <= -log2(FC)] <- "Down"
head(data)
# 标记方data# 标记方式（一）
# 根据数据框中的Marker列，1的为标记，0的为不标记
data$label=ifelse(data$Marker == 1, as.character(data$Name), '')
# （或）标记方式（二）
# 根据PValue小于多少和log[2]FC的绝对值大于多少筛选出合适的点
# PvalueLimit = 0.0001
# FCLimit = 5
# data$label=ifelse(data$PValue < PvalueLimit & abs(log2(data$FC)) >= FCLimit, as.character(data$Name), '')

# 绘图
ggplot(data,aes(log2(data$FC),-1*log10(data$PValue))) +    # 加载数据，定义横纵坐标
  geom_point(aes(color = sig)) +                           # 绘制散点图，分组依据是数据框的sig列
  labs(title="volcanoplot",                                # 定义标题，x轴，y轴名称
       x="log[2](FC)", 
       y="-log[10](PValue)") + 
  # scale_color_manual(values = c("red","green","blue")) + # 自定义颜色，将values更改成你想要的三个颜色
  geom_hline(yintercept=-log10(PValue),linetype=2)+        # 在图上添加虚线
  geom_vline(xintercept=c(-log2(FC),log2(FC)),linetype=2)+ # 在图上添加虚线
  geom_text_repel(aes(x = log2(data$FC),                   # geom_text_repel 标记函数
                      y = -1*log10(data$PValue),          
                      label=label),                       
                  max.overlaps = 10000,                    # 最大覆盖率，当点很多时，有些标记会被覆盖，调大该值则不被覆盖，反之。
                  size=3,                                  # 字体大小
                  box.padding=unit(0.5,'lines'),           # 标记的边距
                  point.padding=unit(0.1, 'lines'), 
                  segment.color='black',                   # 标记线条的颜色
                  show.legend=FALSE)
```

## 韦恩图

```R
# 加载R包，没有安装请先安装  install.packages("包名") 
library(venn)         #韦恩图（venn 包，适用样本数 2-7）
library(VennDiagram) 

# 读取数据文件
venn_dat <- read.delim('https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/Venn/flower.txt')                      # 这里读取了网络上的demo数据，将此处换成你自己电脑里的文件
venn_list <- list(venn_dat[,1], venn_dat[,2], venn_dat[,3], venn_dat[,4], venn_dat[,5], venn_dat[,6], venn_dat[,7])   # 制作韦恩图搜所需要的列表文件
names(venn_list) <- colnames(venn_dat[1:7])    # 把列名赋值给列表的key值
venn_list = purrr::map(venn_list,na.omit)      # 删除列表中每个向量中的NA
venn_list <- purrr::map(venn_list, function(x){x[x!=""]}) # 删除列表中每个向量中的""

#作图
venn(venn_list,
     ilabels="counts",
     zcolor='style', # 调整颜色，style是默认颜色，bw是无颜色，当然也可以自定义颜色
     opacity = 0.3,  # 调整颜色透明度
     box = F,        # 是否添加边框
     ilcs = 0.5,     # 数字大小
     sncs = 1        # 组名字体大小
)

# 更多参数 ?venn查看

# 查看交集详情,并导出结果
inter <- get.venn.partitions(venn_list)
for (i in 1:nrow(inter)) inter[i,'values'] <- paste(inter[[i,'..values..']], collapse = '|')
inter <- subset(inter, select = -..values.. )
inter <- subset(inter, select = -..set.. )
write.table(inter, "result.csv", row.names = FALSE, sep = ',', quote = FALSE)
```


## 箱线图


```R
# 加载R包，没有安装请先安装  install.packages("包名") 
library(ggplot2)
library(reshape2)  # 用于转换数据
library(ggsignif)  # 用于添加显著性标签

# 读取箱线图数据文件
df = read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/boxplot/boxplot.txt",
                 header = T    # 指定第一行是列名
)
# 把数据转换成ggplot常用的类型（长数据）
df = melt(df)
# 当你使用 melt(df) 时，melt 会自动识别哪些列是 ID 变量（通常是不会变化的标识列，如行名称、分类列等），并且在控制台输出提示。如果你希望明确指定 ID 变量，可# 以手动指定，例如：
# 使用特定的 ID 列，例如假设 ID 列是 "X"
# df <- melt(df, id.vars = "X")

# melt这个函数也可以通过下面这部分余顺太写的代码进行替换，但是用我写的这段代码不知道为什么显示不出来p值。
# S1 <- data.frame(x = df$X, variable = rep("sample1",1000),value = df$Sample1)
# S2 <- data.frame(x = df$X, variable = rep("sample2",1000),value = df$Sample2)
# S3 <- data.frame(x = df$X, variable = rep("sample3",1000),value = df$Sample3)
# S4 <- data.frame(x = df$X, variable = rep("sample4",1000),value = df$Sample4)
# df <- rbind(S1,S2,S3,S4)

# 要用data.frame来进行结合，因为数据类型不同，而matrix和bind只能结合相同类型数据。比如下面这个代码就不行。
# S1 <- cbind(x = ddf$X, variable = rep("sample1",1000),value = ddf$Sample1)


# 绘图
ggplot(df,aes(x=variable,y=value,fill=variable))+
  # stat_boxplot(geom = "errorbar",    # 添加误差线
  #  width=0.3)+
  geom_boxplot(alpha = 1,              # 透明度
               outlier.color = "black" # 外点颜色
  )+
  theme_bw()+                          # 白色主题
  theme(
    axis.text.x = element_text(angle = 90,
                               vjust = 0.5
    )       # x轴刻度改为倾斜90度，防止名称重叠
  )+
  geom_signif(                         # 添加显著性标签
    comparisons=list(c("Sample1","Sample2"),c("Sample3","Sample4")), # 选择你想在哪组上添加标签
    step_increase = 0.1,
    test="t.test",                     # "t 检验，比较两组（参数）" = "t.test","Wilcoxon 符号秩检验，比较两组（非参数）" = "wilcox.test"
    test.args = list("var.equal" = T), # 等方差 
    map_signif_level=F                 # 标签样式F为数字，T为*号
  )

```


## 小提琴图

```R
# 加载R包，没有安装请先安装  install.packages("包名") 
library(ggplot2)
library(reshape2)  # 用于转换数据
library(ggsignif)  # 用于添加显著性标签

# 加载R包，没有安装请先安装  install.packages("包名") 
library(ggplot2)
library(reshape2)

# 读取箱线图数据文件
df = read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/boxplot/boxplot.txt",
                 header = T    # 指定第一行是列名
)

# 把数据转换成ggplot常用的类型（长数据）
df = melt(df)                    # melt出自reshape2包
head(df)                         # 查看转换完成的数据的前几行
# 绘图
ggplot(df,aes(x=value,   
              fill=variable,     # fill填充颜色，根据变量名赋值
              colour=variable))+ # colour图形边界颜色，根据变量名赋值
  geom_density(alpha=0.2,        # 填充颜色透明度
               size=1,           # 线条粗细
               linetype = 1      # 线条类型1是实线，2是虚线
               )+
  theme_bw()                     # 白色主题

# 补充知识：
# fill   一般是指填充颜色
# color  一般是指线和点的颜色
# colour 一般是指图形边界颜色
# 把数据转换成ggplot常用的类型（长数据）
df = melt(df)
# melt这个函数也可以通过下面这部分余顺太写的代码进行替换。
# S1 <- data.frame(x = df$X, variable = rep("sample1",1000),value = df$Sample1)
# S2 <- data.frame(x = df$X, variable = rep("sample2",1000),value = df$Sample2)
# S3 <- data.frame(x = df$X, variable = rep("sample3",1000),value = df$Sample3)
# S4 <- data.frame(x = df$X, variable = rep("sample4",1000),value = df$Sample4)
# df <- rbind(S1,S2,S3,S4)

#要用data.frame来进行结合，因为数据类型不同，而matrix和bind只能结合相同类型数据。比如下面这个代码就不行。
# S1 <- cbind(x = ddf$X, variable = rep("sample1",1000),value = ddf$Sample1)

# 绘图
ggplot(df,aes(x=variable,y=value,fill=variable))+
  geom_violin(alpha = 1,              # 透明度
              trim = T,               # 是否修剪尾巴，即将数据控制到真实的数据范围内
              scale = "area",         # 如果“area”(默认)，所有小提琴都有相同的面积(在修剪尾巴之前)。如果是“count”，区域与观测的数量成比例。如果是“width”，所有的小提琴都有相同的最大宽度。
              
  )+
  theme_bw()+                          # 白色主题
  theme(
    axis.text.x = element_text(angle = 90,
                               vjust = 0.5
    )       # x轴刻度改为倾斜90度，防止名称重叠
  )+
  geom_signif(                         # 添加显著性标签
    comparisons=list(c("Sample1","Sample2"),c("Sample3","Sample4")), # 选择你想在哪2组上添加标签
    step_increase = 0.1,
    test="t.test",                     # "t 检验，比较两组（参数）" = "t.test","Wilcoxon 符号秩检验，比较两组（非参数）" = "wilcox.test"
    test.args = list("var.equal" = T),  # 等方差    
    map_signif_level=F                 # 标签样式F为数字，T为*号
  )
```

## 核密度图

```R
# 加载R包，没有安装请先安装  install.packages("包名") 
library(ggplot2)
library(reshape2)

# 读取箱线图数据文件
df = read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/boxplot/boxplot.txt",
                 header = T    # 指定第一行是列名
)

# 把数据转换成ggplot常用的类型（长数据）
df = melt(df)                    # melt出自reshape2包
head(df)                         # 查看转换完成的数据的前几行
# 绘图
ggplot(df,aes(x=value,   
              fill=variable,     # fill填充颜色，根据变量名赋值
              colour=variable))+ # colour图形边界颜色，根据变量名赋值
  geom_density(alpha=0.2,        # 填充颜色透明度
               size=1,           # 线条粗细
               linetype = 1      # 线条类型1是实线，2是虚线
               )+
  theme_bw()                     # 白色主题

# 补充知识：
# fill   一般是指填充颜色
# color  一般是指线和点的颜色
# colour 一般是指图形边界颜色
```

## 双向柱形图

```R
# 加载R包，没有安装请先安装  install.packages("包名") 
library(ggplot2)
library(reshape2)

# 读取双向柱形图数据文件
df= read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/Bidirectional_bar_chart/Bidirectional_bar_chart.txt")   # 这里读取了网络上的demo数据，将此处换成你自己电脑里的文件


# 把数据转换成ggplot常用的类型（长数据）
df = melt(df)                    # melt出自reshape2包
head(df)                         # 查看转换完成的数据的前几行
#   X         variable   value
# 1 Pathway1       Up    35
# 2 Pathway2       Up    27
# 3 Pathway3       Up    58
# 4 Pathway4       Up    24
# 5 Pathway5       Up     4
# 6 Pathway6       Up    58

# 绘图
ggplot(df, aes(
  x = factor(X,levels = unique(X)),             # 将第一列转化为因子，目的是显示顺序与文件顺序相同，否则按照字母顺序排序
  y = ifelse(variable == "Up", value, -value),  # 判断分组情况，将两个柱子画在0的两侧
  fill = variable)) +
  geom_bar(stat = 'identity')+                                # 画柱形图
  coord_flip()+                                               # x轴与y轴互换位置
  geom_text(                                                  # 在图形上加上数字标签
    aes(label=value,                                          # 标签的值（数据框的第三列）
        # vjust = ifelse(variable == "Up", -0.5, 1),          # 垂直位置。如果没有coord_flip()，则可以取消这行注释
        hjust = ifelse(variable == "Up", -0.4, 1.1)           # 水平位置
    ),
    size=2                                                    # 标签大小
    
  )+
  scale_y_continuous(                                         # 调整y轴
    labels = abs,                                             # 刻度设置为绝对值
    expand = expansion(mult = c(0.1, 0.1)))                   # 在y轴的两侧，留下一部分的空白位置，防止加标签的时候，显示不全

```

## 相关性热图

```R
# 加载R包，没有安装请先安装  install.packages("包名") 
library(pheatmap)

# 读取相关性热图数据文件
df= read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/Correlation-heat-map/Correlation%20heat%20map.txt",# 这里读取了网络上的demo数据，将此处换成你自己电脑里的文件
               header = T,
               row.names = 1
)   

# 计算相关性
r <- cor(df,
         method = "pearson",           # 计算相关性的方法有"pearson", "spearman", "kendall"
         use = "pairwise.complete.obs" # 缺失值处理的方式
) 

# 绘制热图
pheatmap(r, 
         show_colnames = TRUE,   # 是否显示列名
         show_rownames=TRUE,     # 是否显示行名
         fontsize=5,             # 字体大小
         color = colorRampPalette(c('#0000ff','#ffffff','#ff0000'))(50), # 指定热图的颜色
         annotation_legend=TRUE, # 是否显示图例
         border_color=NA,        # 边框颜色 NA表示没有
         scale="none",           # 指定归一化的方式。"row"按行归一化，"column"按列归一化，"none"不处理
         cluster_rows = TRUE,    # 是否对行聚类
         cluster_cols = TRUE     # 是否对列聚类
)

# 更多参数可以输入 ?pheatmap 查看
```

## 雷达图

```R
# 加载R包，没有安装请先安装  install.packages("包名") 
library(ggradar) # 此包需要从github安装 devtools::install_github("ricardo-bion/ggradar")
library(ggplot2)

df <- data.frame(
  X = c("gene2", "gene1", "gene3", "gene4"),
  Sample1 = c(142.9, 130.4, 1392.7, 2156.7),
  Sample2 = c(136.4, 1392.7, 129.4, 2050.9),
  Sample3 = c(118.1, 1330.0, 136.9, 1953.7),
  Sample4 = c(200.0, 763.4, 63.4, 1059.3),
  Sample5 = c(20.3, 310.8, 55.3, 657.9),
  Sample6 = c(16.8, 158.4, 25.1, 387.8)
)


# 绘图
ggradar(df,
        grid.max = max(df[,-1]),                 # 设置坐标轴的最大值
        grid.mid = max(df[,-1])/2,               # 设置坐标轴的中间值
        grid.min = 0,                            # 设置坐标轴的最小值
        grid.label.size = 4,                     # 坐标轴百分比标签大小
        axis.label.size = 5,                     # 组名标签字体大小
        group.colours = rainbow(length(df[,1])), # 设置颜色，数量跟第一列的个数相同
        background.circle.colour = "white",      # 设置背景颜色
        group.point.size = 2,                    # 点大小
        group.line.width = 2,                    # 线条粗细
        plot.legend = T,                         # 是否显示图例
        legend.position = "right",               # 图例位置"top", "right", "bottom", "left"
        legend.title = "",                       # 图例标题
        legend.text.size = 10,                   # 图例文字大小
        plot.title   = "Title",                  # 标题名称
        plot.extent.x.sf = 1.2,                  # 设置图片横向延伸空间，防止外圈文字显示不全
        plot.extent.y.sf = 1.2,                  # 设置图片纵向延伸空间，防止外圈文字显示不全
)
# 更多选项?ggradar查看，支持ggplot2其他函数扩展
```

## 气泡图

```R
library(ggplot2)

# 读取富集气泡图数据文件
df= read.delim("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/bubble/bubble.txt")# 这里读取了网络上的demo数据，将此处换成你自己电脑里的文件

# 绘图
ggplot(df,aes(x = Ratio, 
              y = reorder(Term,Enrichment,sum), # 按照富集度大小排序
              size = Size,
              colour=Enrichment)) +
  geom_point(shape = 16) +                    # 设置点的形状
  labs(x = "Ratio", y = "Pathway")+           # 设置x，y轴的名称
  scale_colour_continuous(                    # 设置颜色图例
    name="Enrichment",                        # 图例名称
    low="green",                              # 设置颜色范围
    high="red")+
  scale_radius(                               # 设置点大小图例
    range=c(2,4),                             # 设置点大小的范围
    name="Size")+                             # 图例名称
  guides(   
    color = guide_colorbar(order = 1),        # 决定图例的位置顺序
    size = guide_legend(order = 2)
  )+
  theme_bw()                                  # 设置主题

```

## 词云图

```R
library(jiebaRD) 
library(jiebaR)                 
library(wordcloud2)

# 1. 通过一段话来进行制作词云图

# 1.1 先将一段文字转成词频
text = "蛋白质组(Proteome)的概念最先由Marc Wilkins提出，指由一个基因组(genome)，或一个细胞、组织表达的所有蛋白质(Protein). 蛋白质组的概念与基因组的概念有许多差别，它随着组织、甚至环境状态的不同而改变. 在转录时，一个基因可以多种mRNA形式剪接，并且，同一蛋白可能以许多形式进行翻译后的修饰. 故一个蛋白质组不是一个基因组的直接产物，蛋白质组中蛋白质的数目有时可以超过基因组的数目. 蛋白质组学(Proteomics)处于早期“发育”状态，这个领域的专家否认它是单纯的方法学，就像基因组学一样，不是一个封闭的、概念化的稳定的知识体系，而是一个领域. 蛋白质组学集中于动态描述基因调节，对基因表达的蛋白质水平进行定量的测定，鉴定疾病、药物对生命过程的影响，以及解释基因表达调控的机制. 作为一门科学，蛋白质组研究并非从零开始，它是已有20多年历史的蛋白质(多肽)谱和基因产物图谱技术的一种延伸. 多肽图谱依靠双向电泳(Two-dimensional gel electrophoresis, 2-DE)和进一步的图象分析；而基因产物图谱依靠多种分离后的分析，如质谱技术、氨基酸组分分析等."
# 也可以通过一下命令读取文本
# text <- readLines("https://github.com/yushuntai/R-learning/blob/word-cloud/%E4%B8%80%E6%AE%B5%E8%AF%9D.txt")

# 1.2 初始化分词器 worker，并将 stopwords.txt 文件中的词作为“停止词”列表。停止词通常包含在
# 文本分析中不需要的常见词汇，如“的”、“是”等。这些词会被排除，以便更准确地聚焦于有意义的词频内容。
initialize <-  worker(stop_word="stopwords.txt")   # 这个用网址链接不了，只能读取文件，可以下载下来再读取，网址是：# https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/word-cloud/stopwords.txt

df<-freq(initialize[text]) # 计算词频

# 绘图
wordcloud2(df, 
           size = 1,                  # 字体大小,这里的字体改变也可以改变整个图片在绘图框里的大小，可以试下
           fontFamily = 'Segoe UI',   # 字体
           fontWeight = 'bold',       # 字体粗细
           color = 'random-dark',     # 字体颜色
           backgroundColor = "white", # 背景颜色
           minRotation = -pi/4,       # minRotation和maxRotation控制文本旋转角度的范围
           maxRotation = pi/4,
           rotateRatio = 0.4,         # 文本旋转的概率 0.4表示大约有40%的词发生了旋转
           shape = "circle"           # 轮廓形状
)

# 2. 通过词频文件制作词云图

df <- read.csv("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/word-cloud/%E8%AF%8D%E9%A2%91.csv")
#如果制作的词频希望有汉字，则可以在excel中制作好，然后另存为——保存类型——CSV UTF-8(逗号分隔)(*.csv)，然后再将这个保存的导入。
# 比如下面这种汉字型词云图
# df <- read.csv("https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/word-cloud/TAC%E8%AF%8D%E9%A2%91.csv")

# 绘图
wordcloud2(df, 
           size = 0.3,                  # 字体大小
           fontFamily = 'Segoe UI',   # 字体
           fontWeight = 'bold',       # 字体粗细
           color = 'random-dark',     # 字体颜色
           backgroundColor = "white", # 背景颜色
           minRotation = -pi/4,       # minRotation和maxRotation控制文本旋转角度的范围
           maxRotation = pi/4,
           rotateRatio = 0.4,         # 文本旋转的概率 0.4表示大约有40%的词发生了旋转
           shape = "circle"           # 轮廓形状
)

```





# R习题

## 1
```R
14, 13.4, 192.7, 26.7,1.4, 1.7, 29.4, 20.9, 18.1, 10, 13, 17, 20.0, 7, 63.4, 1059.3, 20.3, 31, 53, 65, 16, 15, 25, 38
```
将这几个数，形成第一个df，然后再利用一行命令形成第二个df，一行命令形成第三个df，两行命令形成第四个df，再通过一行命令形成第一个df。查看Sample4属于第几列，查看gene3属于第几行，将Sample4的gene3更改为12，查看多少行多少列，查看数据格式。计算每一行的平均值，计算每一列的平均值。
将Sample6那一列数据改成 17,17，4176，88，然后再将gene1那一行改成 6，6.1，6.2, 6.3, 6.4, 6.5。


![image](https://github.com/user-attachments/assets/4e6b9ba5-799e-477f-a94d-02a14a85cfc1)


## 2

```R
Squid<-read.table(file = "https://raw.githubusercontent.com/yushuntai/R-learning/refs/heads/A-beginner's-guide-to-R/%E4%B9%8C%E8%B4%BC%E6%95%B0%E6%8D%AE.txt",header = T,dec = ".");Squid

（1）将该数据Location为1，2，3的行全部提取出来
（2）将该数据Location除了4以外的行全部提取出来
（3）将该数据Sample序号大于6小于14的行全部提取出来
（4）将该数据Sample序号大于6并且Location=1的行全部提取出来
（5）将Sex为1和Location为1或者2的行全部提取出来
（6）将MONTH排序之后的Squid展示出来
（7）将MONTH排序之后的Sample展示出来
（8）将Location对应的1，2，3，4，全部改成甲，乙，丙，丁。
（9）求Location为1,2,3,4时分别对应的GSI的平均值
（10） 将Squid里面的Sample, MONTH, Sex这三列数据提取出来，并重新分别命名为A,B，C
（11）用函数统计一下每一行和每一列有多少个缺失值，再统计一下每一列有多少个零值。
（12）将Squid的行变成列，列变成行，并将转变后的每一行命名为1到16.
（13）MONTH的每个值是否存在于Location中,对应的MONTN在第几行。
（14）Location那一列是否有重复值？
（15）挑出GSI里面最大的5个值
```




## R习题答案

## 1

```R
df <- matrix(c(14, 13.4, 19, 26, 1.4, 1.7, 29.4, 20, 18, 10, 13, 17, 20.0, 7, 63.4, 10, 20.3, 31, 53, 65, 16, 15, 25, 38), nrow = 4, byrow = TRUE)
colnames(df) <- c("Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6")
df <- data.frame(df)
df$x <- c("gene1","gene2","gene3","gene4");df   #给矩阵df添加一列
df <- df[, c("x", colnames(df)[-7])];df   #调整列的顺序
df$天干 <- c("甲","乙","丙","丁");df

# 添加一行
new_row <- data.frame(
  x = "gene5",
  Sample1 = 1,
  Sample2 = 2,
  Sample3 = 3,
  Sample4 = 4,
  Sample5 = 5,
  Sample6 = 6,
  天干 = "戊"
)

df <- rbind(df, new_row);df   # 使用 rbind() 添加新行

df <- df[-5,-8];df   #删除第五行和第8列即返回第一个df
which(colnames(df)=="Sample4")  #查看Sample4属于第几列
which(df$x=="gene3")   #查看gene3属于第几行，使用which(rownames(df) == "gene3")不行，是因为gene3不是行名，先执行rownames(df) <- df$x就可以执行which了。
df[df$x=="gene3",which(colnames(df)=="Sample4")] <- c(12)   #将Sample4的gene3更改为12.
dim(df);class(df)  #查看多少行多少列，什么数据格式。
sapply(df[,2:7], mean)   #计算每一列的均值，或者apply(df[ , -1], 2, mean)
apply(df[ , -1], 1, mean)   #计算每一行的均值。
df[2, -1] <- c(6, 6.1, 6.2, 6.3, 6.4, 6.5)  #[2, -1]表示df的第2行，-1表示除了第一列（因为该列是gene），全部进行重新赋值。

```

## 2

```R
# （1）
Squid[Squid$Location==1|Squid$Location==2|Squid$Location==3,]

# （2）
Squid[Squid$Location!=4,]

# （3）
Squid[Squid$Sample >6 & Squid$Sample < 14,]

# （4）
Squid[Squid$Sample>6 & Squid$Location==1,]

# （5）
Squid[Squid$Sex==1 & (Squid$Location==1|Squid$Location==2),]

# （6）
Squid[order(Squid$MONTH),]

# （7）
Squid$Sample[order(Squid$MONTH)]

# （8）
Squid$Location <- factor(Squid$Location, levels = c(1, 2, 3, 4), labels = c("甲", "乙", "丙", "丁"))

# （9）
tapply(Squid$GSI, Squid$Location, mean)    # Squid$GSI是求mean的对象，Squid$Location是依照的分类。

#（10）
tmp <- cbind(Squid$Sample, Squid$MONTH, Squid$Sex)
colnames(tmp) <- c("A","B","C")
#colnames(cbind(Squid$Sample, Squid$MONTH, Squid$Sex)) <- c("A","B","C")   #这句是运行不通的，因为cbind

#（11）
NAperCol <- function(x){a <- is.na(x); colSums(a)}   #每一列缺失值的个数。NAperCol为函数名字，is.na(x)生成一个与x维数相同的布尔矩阵，并将x矩阵中的缺失值计为TRUE，非缺失值计为FALSE；colSums是R中已有的函数，colsum函数的对象通常为数值矩阵，也可以是布尔矩阵，它会将布尔矩阵中的TRUE计为1，FALSE计为0；并且变量的任何位置出现了空值则colSum函数的输出就为空值，可以通过设定na.rm = TRUE来实现；
NAperCol(Squid)

NAperRow <- function(x){a <- is.na(x); rowSums(a)}   #每一行缺失值的个数。
NAperRow(Squid)

ZEROperCol <- function(x){a <- (x==0); colSums(a, na.rm = T)}  # 每一行有多少零值，na.rm=T表示移除缺失值
ZEROperCol(Squid)

# （12）
tmp <- t(Squid); colnames(tmp) <- seq(1:16)

# （13）
Squid$MONTH %in% Squid$Location   # MONTH的每个值是否存在于Location中
which(Squid$MONTH %in% Squid$Location)    #对应的MONTH的行号

# （14）
length(unique(Squid$Location))==nrow(Squid)   #计算去重后列的长度是否等于数据框的总行数

# (15)
tail(sort(Squid$GSI),5)   #先从小到大排序后，再取后面5个
```
